# 第三章 目标文件里有什么

## 3.1 目标文件的格式

现在 PC 平台流行的可执行文件格式（Executable）主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format）。
不光是可执行文件（Windows 的 ``.ext `` 和 Linux 的 ELF 可执行文件，动态链接库（DLL，Dynamic Linking Library）（Windows 的 ``.dll`` 和 Linux 的 ``.so`` 都是按照可执行文件的格式来存储。

目标文件指的是源代码编译后但未进行链接的那些中间文件（Windows 的 ``.obj``  和 Linux 的 ``.o``）。

以 Linux 为例，ELF 文件格式包括以下几类：

- 可执行文件（Executable File）：包含了可以直接访问的程序，Linux 下一般没有扩展名。
- 可从定位文件（Relocatable File）：包含代码和数据，可以被用来链接成可执行文件和共享目标文件，静态链接库也可以归为此类。
- 共享目标文件（Shared Object File）：包含代码和数据。
- 核心转储文件（Core Dump File）：当程序意外终止时，系统将该进程的地址空间的内容及终止时的一些信息转储到核心转储文件。

## 3.2 目标文件是什么样的

目标文件中包含编译后的指令、数据等，一般目标文件将这些信息按照不同的属性，以节（Section）或者段（Segment）的形式存储。

一个简单的程序被编译成目标文件后的结构如图所示：

<div align="center">
<img src="https://github.com/xpmemeda/task/raw/master/chrome-review-list/Link-Load-and-Library/resource/3-1.jpg" width = "700" height = "450" alt="图 3-1 程序与目标文件"/>
</div>

ELF 文件的开头是一个文件头，它描述了整个文件的属性，包括文件是否可执行、是静态链接还是动态链接、入口地址（如果是可执行文件）、目标硬件、目标操作系统等信息。**文件头还有一个段表**。

一般 C 语言源码都会被编译为机器代码，保存在 ``.text`` 段；已经初始化的全局变量和静态变量保存在 ``.data`` 段；未初始化的全局变量和静态变量放在 ``.bss`` 段。

Q：为什么要区分初始化的和未初始化的数据？

A：``.bss`` 段其实是不占据空间的，它只不过是为未初始化的全局变量和静态变量预留位置而已。

总体来说，程序源代码被编译后主要分成两种段：程序指令和程序数据。代码段属于程序指令，而数据段和 ``.bss`` 段属于程序数据。

**为什么程序要被区分为代码段和数据段？**

1. 一般来说代码段是只读的，而数据段是可读写的，二者区分开来可以防止程序的指令被有意或者无意的改写。

2. 提高程序的局部性。

3. 当系统中运行着多个该程序的副本时，通常只需要保存一份指令部分，而数据部分则需要保存多份。

## 3.3 挖掘 SimpleSection.o

Linux 命令行中使用 ``objdump -h`` 可以查看可执行文件的段基本信息，通常会显示 6 个主要的段：

- ``.text``：代码段
- ``.data``：数据段
- ``.bss``：未初始化的数据段
- ``.rodata``：只读数据段
- ``.comment``：注释信息段
- ``.note.GNU-stack``：堆栈提示段

使用 ``size`` 命令可以查看每个段的长度。

### 3.3.1 代码段

### 3.3.2 数据段和只读数据段

当程序中包含只读变量（包括字符串常量）时，可执行文件中通常会包含一个 ``.rodata`` 段。设置 ``.rodata`` 段一方面可以支持 C++ 语法中的 ``const`` 关键字，另一方面可以提高程序的安全性。

### 3.3.3 BSS 段

初始化为零的数据会被放在 ``.bss`` 段，比如：

```cpp
static int x = 0;
```

### 3.3.4 其他段

在 GCC 中可以指令变量所处的段名，比如下面这条语句将 ``x`` 放在了名为 ``.name`` 的段中：

```cpp
__attribute__((section(".name"))) int x = 1;
```

## 3.4 ELF 文件结构描述

相关结构和常量都定义在 elf.h 头文件中。

### 3.4.1 文件头

ELF 文件头定义了 ELF 魔数、文件机器字节长度、数据存储方式、版本、运行平台、ABI 版本、ELF 重定位类型、硬件平台、硬件平台版本、程序头入口和长度、段表的位置和长度、段的数量等。

操作系统在加载可执行文件时会确认魔数是否正确，不正确则拒绝加载。

### 3.4.2 段表

段表（Section Header Table）是保存段基本属性的结构。
它描述了 ELF 的各个段的信息，如段名、段的长度、在文件中的偏移、读写权限等。

Linux 下使用 ``readelf -s`` 命令可以查看目标文件的各个段属性。

### 3.4.3 重定位表

重定位表（Relocation Table）的作用：

1. 引用外部模块的符号，链接时需要重定位表来获得实际地址。

2. 代码段和数据段中那些引用绝对地址的位置，都需要在链接时使用重定位表来重新计算地址。

重定位表分为代码段重定位表和数据段重定位表，它们的名字通常为 ``.rel.text`` 和 ``.rel.data``。

### 3.4.4 字符串表

ELF 文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。
一种常见的做法是把字符串集中存放到一个表，然后使用字符串在表中的偏移来引用字符串。
在 ELF 文件中引用字符串只须给出一个数字下标即可。

字符串表名通常为 ``.strtab``。

## 3.5 链接的接口-符号

在链接中，函数和变量统称为符号（Symbol），函数名和变量名统称为符号名（Symbol Name）。

每一个目标文件中都有一个相应的符号表（Symbol Table），这个表里面记录了目标文件所用到的所有符号。
每个定义的符号有一个对应的值，叫做符号值（Symbol Value），对于变量和函数来说，符号值就是它们的地址。

符号包括这样几类：

- 定义在本目标文件中的全局符号，可以被其他目标文件引用。
- 在本目标文件中引用的全局符号，却没有在本目标文件中定义，这一般叫做外部符号（External Symbol）。
- 段名，它的值就是该段的起始地址。
- 局部符号，只在编译单元的内部可见，比如 C++ 中的 ``static`` 函数和变量。
- 行号信息，可选的用于调试的信息。

### 3.5.1 ELF 符号表结构

符号表名通常为 ``.symtab``。

### 3.5.2 特殊符号

链接器会给 ELF 文件定义一些特殊符号：

- __executable_start，该符号为程序起始地址。
- __etext，该符号为代码段结束地址。
- _edata，该符号为数据段结束地址。
- _end，该符号为程序结束地址。

### 3.5.3 符号修饰与函数签名

为了防止不同语言的库出现符号名冲突，编译器会把源码中的函数名和变量名加一些符号修饰。
UNIX 下的 C 语言就规定，所有变量和函数经过编译之后，相对应的符号名前加上下划线 ``_``，而 Fortan 语言前后都加上下划线。

**C++ 符号修饰**

C++ 支持函数的重载，因此在解析符号时需要更为复杂的方式：

- 使用名称空间（Namespace）
- 符号修饰（Name Decooration）或者符号改编（Name Mangling）

对应同一个函数签名（Function Signature），不同的编译器会产生不同的符号修饰，因此必然会导致不同编译器产生的目标文件无法正常相互链接。

函数签名包含了一个函数的信息，包括函数名、参数类型、它所在的类和名称空间及其他信息。

### 3.5.4 extern "C"

C++ 为了与 C 兼容，在符号的管理上，C++ 有一个用来声明或定义一个 C 的符号的 ``extern "C"` 关键字语法：

```cpp
extern "c" {
    int func(int);
    int var;
}
```

或者

```cpp
extern "C" int func(int);
extern "C" int var;
```

此外，C++ 还提供了一个宏 ``__cplusplus``，C++ 编译器在编译 C++ 程序时会默认定义这个宏，程序员可以使用这个宏来判断当前编译单元是不是 C++ 代码。
比如下面这段代码：

```cpp
#ifdef __cplusplus
extern "C" {
#endif
void* memset (void*, int, size_t);
#ifdef __cplusplus
}
#endif
}
```

### 3.5.5 弱符号与强符号

程序在编译时经常会碰到重复定义的问题，这其实就是强符号冲突导致的。
在 C/C++ 中，编译器默认函数和初始化了的全局变量为强符号（Strong Symbol），未初始化的全局变量为弱符号（Weak Symbol）。我们也可以通过 GCC 中的 ``__attribute__((weak))`` 来把一个函数或变量声明为弱符号。

链接过程中，链接器会按照如下规则来出来重名的符号。

1. 不允许强符号被定义多次。
2. 优先使用强符号。
3. 没有强符号，只有多个弱符号时，选择其中占用空间最大的哪个。

**强引用和弱引用**

最终链接可执行文件时，如果还没有找到某个符号的定义，则通常会提示未定义错误，这样的引用被称为强引用（Strong Reference），与之对应的还有一个中弱引用（Weak Reference），弱引用即使没找到定义也不会报错，而是转而使用 0 来表示其符号值。

> :warning: 弱引用虽然在编译链接阶段没有报错，但是在运行阶段可能会出错，比如函数名的地址指向 0 会引发非法访问的错误。

这种弱符号和弱引用的机制对于库而言非常有用，比如空中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数；
或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块还可以正常使用。

## 3.6 调试信息

GCC 编译时加上 ``-g`` 选项就会在目标文件中留下调试信息，即多出很多名字中含有 ``debug`` 的段。
