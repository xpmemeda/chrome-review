# 第六章 可执行文件的装载与进程

## 6.1 进程虚拟地址空间

Q：程序和进程有什么区别？

A：程序是一个静态的概念，他就是一些预先编译好的指令和数据集合的一个文件。
进程则是一个动态的概念，他是程序运行时的一个过程。

程序被运行起来之后，它将拥有自己的虚拟地址空间（Virtual Address Space），这个地址的大小由计算机硬件平台决定。

在 32 位系统中，整个 4GB 内存被分成两部分，其中操作系统本身用去一部分，从地址 0xC0000000 到 0xFFFFFFFF，共 1GB。
剩下的从 0x00000000 到 0xBFFFFFFF 共 3GB 都是留给进程来使用的。

## 6.2 装载的方式

### 6.2.1 覆盖装入

已经淘汰了。

### 6.2.2 页映射

页映射（Paging）是虚拟内存技术的一部分。
在加载可执行文件的时候，它并不是把程序中所有的代码和数据一次性都装入内存，而是以页（Page）为单位分别装入。

## 6.3 从操作系统角度看可执行文件的装载

在虚拟内存中，内存管理单元（Memory Management Unit，MMU）提供虚拟地址和物理地址的转换功能。

### 6.3.1 进程的建立

操作系统创建一个进程要做 3 件事情：

1. 创建一个独立的虚拟地址空间。
2. 读取可执行文件头，建立虚拟地址空间与可执行文件的映射关系。
3. 将 CPU 的指令寄存器设置成可执行文件的入口地址，启动运行。

### 6.3.2 页错误

当 CPU 无法在物理地址中找到某页时会引发一个页错误（Page Fault），然后操作系统会接过控制权，寻找专门的错误处理例程来处理这种情况。

## 6.4 进程虚存空间分布

### 6.4.1 ELF 文件链接视图与执行视图

在可执行文件中虽然有多达十几个甚至几十个段，但是段的属性无外乎**是否可读、是否可写、是否可执行**的几种组合。
因此操作系统在装载可执行文件时，会把多个读写属性相同的段当作同一块区域来操作。

由此衍生出来文件链接视图（Linking View）和执行视图（Execution View）两个概念，后者把相同属性的段看作是同一块区域，这个区域被称为虚拟内存区域（VMA，Virtual Memory Area）。

### 6.4.2 堆和栈

VMA 除了用来表示可执行文件中的各个同属性段组合之外，还用于进程管理虚拟内存的地址空间。
一个进程基本上可以划分为如下几种 VMA 区域：

- 代码 VMA，权限为只读、可执行：有映像文件
- 数据 VMA，权限为可读写，可执行：有映像文件
- 堆 VMA，权限为可读写，可执行：无映像文件，匿名，可向上扩展
- 栈 VMA，权限为可读写，不可执行：无映像文件，匿名，可向下扩展

### 6.4.3 堆的最大申请数量

Linux 下虚拟地址空间分给进程进程本身的是 3GB，所以堆区能申请到的最大内存不会超过 3GB。
除此之外，malloc 的最大申请内存还受到操作系统版本、程序本身大小、用到的动态库数量和大小、栈的数量和大小等影响。

### 6.4.4 段地址对齐

由于装载过程是以页为单位的，如果可执行文件的每个段都以页为单位对齐，会导致文件段的内部有许多碎片，浪费磁盘空间。

一个解决的办法是：让各个段接壤部分共享一个物理页面，然后将该物理页面分别映射两次到虚拟空间地址。如图所示：

<div align="center">
<img src="https://github.com/xpmemeda/task/raw/master/chrome-review-list/Link-Load-and-Library/resource/6-11.jpg" width = "700" height = "350" alt="图 6-11 ELF 文件段合并情况"/>
</div>

### 6.4.5 进程栈初始化

进程刚启动的时候需要知道运行环境和运行参数等信息，常见的做法是操作系统在进程启动之前将这些信息提前保存到进程虚拟空间的栈中（也就是 VMA 中的 Stack VMA）。

## 6.5 Linux 内核装载 ELF 过程简介

也就是上述创建进程的第二步（建立可执行文件和虚拟内存的映射关系）的细化。

1. 检查 ELF 可执行文件的有效性，比如魔数、程序头表中段的数量。
2. 寻找动态链接的 ``.interp`` 段，设置动态链接路径。
3. 根据 ELF 可执行文件的程序头表的描述，对 ELF 文件进行映射，比如代码、数据。
4. 初始化 ELF 进程环境，比如设置环境变量和程序参数。
5. 将 fork 系统调用的返回地址改成 ELF 可执行文件的入口点。

## 6.6 Windows PE 的装载