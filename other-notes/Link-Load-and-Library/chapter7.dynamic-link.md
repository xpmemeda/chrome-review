# 第七章 动态链接

## 7.1 为什么要动态链接

静态链接存在一些缺点：

1. 非常占用内存和磁盘空间：

>> 多个程序包含同一份静态库时，使内存和磁盘中有多个相同副本。

>> 单个程序可能会存在同一份静态库的多个拷贝。

2. 程序的开发和发布比较困难：除非重新编译可执行文件，否则不能够使用第三方库的更新。

动态链接不仅可以解决上述静态链接的两个缺点，还能带来以下收益：

1. 由于所有程序采用同一个共享模块，操作系统可以减少内存物理页面的换入换出，也可以增加 CPU 缓存的命中率。

2. 加强程序的兼容性，使得同一个可执行文件运行在不同的系统之上。


在 Linux 系统中，ELF 动态链接文件被称为动态共享对象（DSO，Dynamic Shared Objects），简称共享对象，它们一般以 ``.so`` 结尾。
在 Windows 系统中，动态链接文件被称为动态链接库（DLL，Dynamic Linking Library），它们一般以 ``.dll`` 结尾。

## 7.2 简单的动态链接例子

## 7.3 地址无关代码

### 7.3.1 固定装载地址的困扰

共享库中可能会存在一些包含绝对地址的指令或数据，当可执行文件动态链接多个共享库时，这些库可能会面临绝对地址的冲突问题，因此共享库在装载的时候也需要对这些绝对地址进行重定位。

### 7.3.2 装载时重定位

共享库被装载时，记录其在进程虚拟内存中的实际装载位置作为地址偏移量，然后让库中所有绝对地址都加上该偏移量。

静态链接时的重定位叫做链接时重定位（Link Time Relocation），动态链接时的重定位叫做装载时重定位（Load Time Relocation）。

### 7.3.3 地址无关代码

装载时重定位存在一个巨大的缺陷：包含地址的指令无法在多个进程之间共享。

为了不同的进程可以共享库的指令部分，基本做法是把指令中哪些需要被修改的部分分离出来，跟数据放在一起，这样指令部分就可以保持不变，而数据部分可以在每一个进程中都拥有一个副本。
这种方案就是目前被称为地址无关代码（PIC，Position-independent Code）的技术。

相比于转载时重定位，PIC 不会产生代码段重定位表，因此可以通过一下命令来判断共享库是否采用 PIC：

```bash
readelf -d foo.so | grep TEXTREL
```

如果上述命令有任何输出，则 ``foo.so`` 就不是 PIC 类型共享库。

PIC 实现概要如下：

- 模块内部的函数或数据访问

>> 使用相对寻址方式

- 模块外部的函数或数据访问

>> 在数据段里面建议一个指向这些变量的指针数组，被称为全局偏移表（Global Offset Table），当代码需要引用模块外的函数或者数据时，可以通过 GOT 来间接访问。

此处需要说明一点：函数和数据的引用方式在具体实现上存在细微区别。

在代码编译阶段可以通过增加 ``-fpic`` 或者 ``-fPIC`` 来产生地址无关代码。前者速度更快，但是在某些平台上会受到限制；后者则相反。

地址无关代码除了可以用在共享库上面，还可以用于可执行文件，被称为地址无关可执行文件（PIC，Position-Independent Executable）。
与 ``-fpic`` 和 ``-fPIC`` 对应，产生 PIE 的编译选项为 ``-fpie`` 和 ``-fPIE`` 。

### 7.3.4 共享模块的全局变量问题

首先需要说明：全局变量和静态变量并不是同一个东西。在 C++ 中，静态变量通过关键字 ``static`` 来修饰，可以确定是本模块定义的，而全局变量则确定不了。

考虑下面这个代码片段：

```cpp
extern int global;
int foo() {
    global = 1;
}
```

编译器无法确定 ``global`` 变量是本模块内其他编译单元产生的，还是其他模块产生的。
因此，在这种情况下，对 ``golbal`` 变量的访问都要使用 GOT 来简介完成。

### 7.3.5 数据段地址无关性

不同于代码段地址无关，数据段是每个进程独有的，不需要考虑它被不同进程同时使用的问题，因此只需要采用装载时重定位方法，产生数据段重定位表足以解决问题。

## 7.4 延迟绑定

动态链接比静态链接要灵活许多，但它是以牺牲一部分性能为代价的：

- 对函数或数据访问经常要通过 GOT 来实现，使得程序的运行速度变慢

- 程序开始执行时，动态链接器要进行一次链接工作，导致程序的启动速度变慢。

实际上，一个程序在运行过程中，很多函数并不会用到，比如错误处理函数和一些用户不使用的功能模块等，一开始就把所有的函数都链接好其实是一种浪费。

ELF 采用延迟绑定（Lazy Binding）的做法来避免这种不必要的性能浪费，也就是当函数第一次被用到时才进行绑定。

ELF 使用 PLT（Procedure Linkage Table）这样的数据结构来完成延迟绑定。每个外部函数在 PLT 中都有一个对应的项，以 ``foo()`` 函数为例，它在 PLT 中对应的项的地址暂且称为 foo@plt，下面是 foo@plt 的实现：

```
foo@plt:
jmp *(foo@GOT)
push n
push moduleID
jump _dl_runtime_resolve
```

如果 GOT 中有保存 foo 函数的绝对地址，则直接跳转过去执行。如果没有则把 foo 决议符号的下标和模块 ID 压入栈，然后调用动态链接器的 ``_dl_runtime_resolve`` 函数来完成符号解析和重定位。
``_dl_runtime_resolve`` 在一系列工作以后将 ``fool()`` 的真正地址填入 foo@GOT 中去。

## 7.5 动态链接相关结构

### 7.5.1 “.interp”段

动态连接器的位置既不是操作系统决定的，也不是环境变量指定的，而是可执行文件所指定的。
在动态链接的 ELF 可执行文件中，有个专门的段叫做“.interp”段，里面仅仅保存了一个指向动态链接器的字符串，通常为“/lib/ld-linux.so.2”。

### 7.5.2 “.dynamic”段

这个段中保存着动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表（PIC 没有代码段重定位表，但是有数据段重定位表）的位置、共享对象初始化代码的地址等。

在 Linux 中，下面这条命令可以查看可执行文件或者共享库所依赖的共享库：

```bash
ldd pragram
```

### 7.5.3 动态符号表

动态符号表也是一个段，段名为“.dynsym”。里面保存了目标符号的信息，包括类型、作用域和所属模块等等。

动态符号表只保存动态链接相关的符号，是符号表“.symtab”的一个子集，不过他们的内容是不一样的。

### 7.5.4 动态链接重定位表

重定位所需要的相关信息。

### 7.5.5 动态链接时进程堆栈初始化信息

动态链接器需要在完成链接之后启动该进程，因此需要知道进程堆栈的初始化信息，比如有几个段，程序的入口地址等等。

## 7.6 动态链接的步骤和实现

分为三步：启动动态链接器；装载共享对象；重定位和初始化。

动态链接器完成动态链接之后，将把进程的控制权交给程序入口。

### 7.6.1 动态链接器自举

动态链接库本身也是一个共享对象，但是它必须有一些特殊性：

1. 不可以依赖于其他任何共享对象。

2. 动态链接器本身所需要的全局和静态变量的重定位工作由它自己完成，也叫做自举。

显然，动态链接自举代码中不可以使用全局变量和静态变量。

### 7.6.2 装载共享对象

动态链接器通过查看“.dynamic”段的信息，将所有依赖的共享库装载进来，对于某个共享库还依赖其他共享库的情况，通常采用广度优先的办法来解决。

**符号的优先级**

当不同的两个库定义了同一个函数，则先被装载的生效。

当程序中使用大量共享对象时，应该非常小心重名问题。链接器不报错，容易让程序出现莫名其妙的问题。

### 7.6.3 重定位和初始化

重定位：当上述步骤完成后，链接器可以遍历可执行文件和每个共享库的重定位表，将它们的 GOT/PLT 中每个需要重定位的位置进行修正。

初始化：如果共享库存在“.init”段，则链接器会执行该段代码。

> :warning: 这里的初始化单指执行共享库的“.init”段代码，不包括可执行文件。可执行文件的“.init”段由程序初始化代码部分负责执行。

### 7.6.4 Linux 动态链接器实现

## 7.7 显式运行时链接

支持动态链接的系统往往都支持一种更加灵活的模块加载方式，叫做显式运行时链接（Explicit Runtime Linking），有时也叫做运行时加载。

对应的这种库被称为动态装载库（Dynamic Loading Library），其本质上和一般的共享对象没有区别，只是程序开发者使用它的角度不同。

### 7.7.1 dlopen()

打开一个动态库，讲起居加载到进程的地址空间，完成初始化过程，它的 C 原型定义为：

```cpp
void* dlopen(const char* filename, int flat);
```

详细信息参考《程序员的自我修养》对应章节。

### 7.7.2 dlsym()

查找符号，其定义如下：

```cpp
void* dlsym(void* handle, char* symbol);
```

如果查找的符号是函数或者变量，返回它的地址；如果是常量，则返回值。如果没找到，返回 ``NULL``。

### 7.7.3 dlerror()

每次调用 ``dlopen()``，``dlsym()`` 或者 ``dlclose()`` 之后，可以调用 ``dlerror()`` 来检查上一次调用是否成功。

```cpp
const char* dlerror();
```

### 7.7.4 dlclose()

和 ``dlopen()`` 作用相反。

```cpp
void dlclose(void* handle);
```

动态库的打开和关闭通过引用计数来实现，只有当计数归零时，才真正卸载该模块。

### 7.7.5 运行时装载的演示程序

此小节介绍了如果通过上述 API 实现加载并运行动态库中的某个函数。

前往《程序员的自我修养》查看代码。
