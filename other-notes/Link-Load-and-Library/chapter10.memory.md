# 第十章 内存

## 10.1 程序的内存布局

以 32 位系统为例，虚拟空间大小为 4GB，Linux 系统会将其中的 1GB 分配给内核，该部分被称为内核空间，剩下的被称为用户空间。
用户空间有如下几个区域：

- 栈：用于维护函数调用的上下文
- 堆：用来容纳应用程序动态分配的内存区域。
- 可执行文件印像：这里存储着可执行文件在内存中的印像。
- 动态链接库映射区：用于映射装载的链接库，从地址 0x40000000 开始向高地址增长。
- 保留区：保留区并非一个单一的内存区域，而是对内存中收到保护而禁止访问的内存区域的总称

<div align="center">
<img src="https://github.com/xpmemeda/task/raw/master/chrome-review-list/Link-Load-and-Library/resource/10-1.jpg" width = "400" height = "400" alt="图 10-1 Linux 进程地址空间布局"/>
</div>

Q：段错误（segment fault）因何产生？

A：这是典型的非法指针解引用造成的错误。
常见于使用未初始化的 NULL 指针，以及访问一个不允许读或写的内存地址。

## 10.2 栈与调用惯例

### 10.2.1 什么是栈

栈是一段地址空间，由程序调用子例程而产生。
每个栈帧（Stack Frame）包括如下几个方面：

- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译器自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

在 i386 中，一个函数的活动用 ebp 和 esp 两个寄存器划定范围。esp 始终位于栈的顶部，ebp 则指向当前栈帧的一个固定位置，也被称为帧指针（Frame Point），如下图：

<div align="center">
<img src="https://github.com/xpmemeda/task/raw/master/chrome-review-list/Link-Load-and-Library/resource/10-4.jpg" width = "200" height = "200" alt="图 10-4 活动记录"/>
</div>

esp 始终指向栈顶，会随函数的执行而变化，ebp 则不会，它始终指向一个固定的位置（old ebp）。

i386 的函数调用过程如下所示：

1. 把所有或者部分参数压入栈中
2. 把当前指令的下一条指令压入栈中
3. 跳转到函数体执行（和第二步一起由指令 call 来完成）

跳转到函数体之后，首先要维护 ebp 和 esp 的值：

- push ebp：把 ebp 的值压入栈中
- mov ebp, esp：把 esp 的值赋给 ebp
- 【可选】sub esp, xxx: 在栈上分配一些临时空间
- 【可选】push xxx：如有必要，保存名为 xxx 的寄存器（可重复多个）

当函数返回时，也需要做一些标准操作来维护 ebp 和 esp 的值：

- 【可选】pop xxx：如有必要，恢复保存过的寄存器（可重复多个）
- mov esp, ebp：回复 esp 的同时收回局部变量空间
- pop ebp：从栈中回复保存的 ebp 的值
- ret：从栈中取得返回地址，并跳转到该位置

### 10.2.2 调用惯例

函数的调用方和别调用方对于函数如何调用必须要有一个明确的约定才能确保行为正确，这样的约定被称为调用惯例（Calling Convention），一个调用惯例通常会规定以下这些内容。

- 函数参数的传递顺序和方式
- 栈的维护方式：维持栈在函数调用前后保持一致
- 名字修饰（Name-mangling）的策略

C 语言的默认调用惯例为 cdecl，可以通过 ``__attribute__((cdecl))`` 来声明使用 cdecl 调用惯例：

```cpp
int __attribute__((cdecl)) foo(int n, float m);
```

cdecl 调用惯例的规则：

|参数传递|出栈方|名字修饰|
|:-:|:-:|:-:|
|从右往左压参入栈|函数调用方|直接在函数名前加一个下划线|

### 10.2.3 函数返回值传递

函数的返回值通过 eax 寄存器来实现。
当返回值小于 4 字节时，直接存储进 eax 寄存器；
当返回值大小处于 5~8 字节之间时，几乎所有的调用惯例都采用 eax 和 edx 联合返回的方式来实现。
当返回值大小大于 8 字节时，则通过 eax 来存储返回值的指针，然后将其拷贝到调用调用方的对应变量上。
具体如下：

1. 调用方在栈上额外开辟一片空间，并将这块空间的一部分作为传递返回值的临时对象，这里简称 tmp。
2. 将 tmp 对象的地址作为隐藏参数传递给被调用方。
3. 被调方将返回值拷贝到 tmp 对象，并将 tmp 对象的地址用 eax 传出。
4. 被调方返回之后，调用方将 eax 指向的 tmp 对象赋值给实际变量。

如果编译器不加以优化，这个调用过程将产生两次对象的拷贝过程。因而不到万不得已，不要轻易返回大尺寸对象。

当然，现代编译器基本上都会对这种情况应用返回值优化（Return Value Optimization，RVO）。

## 10.3 堆与内存管理

### 10.3.1 什么是堆

堆是一块巨大的虚拟内存空间，供程序员申请内存资源。

### 10.3.2 Linux 进程堆管理

Linux 提供了两种堆空间的分配方式。

**``brk`` 系统调用**

```cpp
int brk(void* end_data_segment);
```

``brk`` 的实际上是设计进程数据段的结束地址，它可以扩大或缩小数据段，扩大出来的那部分空间可以作为堆空间分配给用户。

Glibc 中还有一个 ``sbrk`` 函数，其功能和 ``brk`` 差不多，但是以一个增量来作为参数。

**``mmap`` 系统调用**

```cpp
void* mmap(void* state, size_t length, int prot, int flags, int fd, off_t offset);
```

``mmap`` 的作用是向操作系统申请一段虚拟空间，该虚拟空间可以映射到某个文件。而当它不将地址空间映射到文件时，则这块空间称为匿名空间，可用于作为堆空间来使用。

``mmap`` 的前两个参数分别用于指定需要申请的空间的起始地址和长度，如果其实地址设为零，则 Linux 系统会自动挑选合适的其实地址。
``prot/flags`` 用于设置申请空间的权限以及映射类型（文件映射、匿名空间等）。
``fd/offset`` 用于文件映射时指定文件描述符和文件偏移，此处可以不关注。

Q：堆空间是如何申请的？

A：一种做法是把进程的内存管理交给操作系统内核去做，但是这样性能会很低，因为系统调用的性能开销很大。
通常来说，堆空间的分配往往是由程序的运行库来管理的：
运行库相当于是向操作系统“批发”了一块较大的内存，然后“零售”给程序用。当全部“售完”或程序有大量的内存需求时，再根据实际情况向操作系统“进货”。

Q：``malloc`` 一次性能够申请的最大空间是多少？

A：从 Linux 进程地址空间布局可以看出来，留给堆的空间还有两处。
第一处是从 BSS 段结束到共享库的开始位置，大概 1GB 不到的空间。
第二处是从共享库的结束位置到栈，大概 2GB 不到的空间，取决于栈的深度以及共享库的大小。
从而可以得出，``malloc`` 最大能申请到的空间是 2GB 左右。
但由于 Linux 不同内核版本对于共享库的装载位置不一样，``malloc`` 能申请到的最大空间也不一样。

### 10.3.3 Windows 进程对管理

### 10.3.4 堆分配算法

**空闲链表**

空闲链表（Free List）的做法是把堆中各个空闲的快按照链表的方式链接起来，当用户申请一块空间时，可以遍历整个链表，直到找到一块大小合适的块并将他拆分。

**位图**

位图（Bitmap）的做法是将整个堆划分为大量的块，每个块大小相同。当用户请求内存时，总是分配整个块给用户，第一个块别称为头（Head），其余的称为主体（Body）。我们可以通过一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位就可以表示一个块，因此称为位图。

**对象池**

实际的内存分配，其大小总是几个固定的值，因此可以把内存空间按这些大小划分为不同的内存池，等到用户申请时直接分配。

在现实应用中，堆的内存分配算法往往是采取多种算法复合而成的。
比如对于 glibc 来说，它对于小于 64 字节的空间申请时采用类似对象池的方法；
而对于大于 512 字节的空间申请采用的是最佳适配算法；
对于大于 64 字节而小于 512 字节的，它会根据实际情况采取上述方法中的最佳这种策略；
对于大于 128KB 的申请，它会使用 ``mmap`` 直接向操作系统申请空间。