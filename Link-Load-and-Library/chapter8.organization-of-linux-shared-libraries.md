# 第八章 Linux 共享库的组织

动态链接有许多优点，但是会导致系统当中存在数量极为庞大的共享对象。
如果没有很好的方法将这些共享对象组织起来，整个系统中的共享对象文件则会散落在各个目录中，给长期的维护、升级造成巨大的问题。
这一章介绍 Linux 下共享库的管理问题。

## 8.1 共享库版本

### 8.1.1 共享库兼容性

共享库的更新通常包括两类：兼容更新和不兼容更新，前者会保留上一版本的所有接口。

这里的接口指的是共享库的二进制进口，即 ABI（Application Binary Interface）。
ABI 对于不同的语言来说，主要包括一些诸如函数调用的堆栈结构、符号名称、参数规则、数据结构的内存分布等方面的规则。

### 8.1.2 共享库版本命名

Linux 有一套规则来命名系统中的每一个共享库，它规定共享库的文件命名规则必须如下：

libname.so.x.y.z

最前面使用前缀 ``lib``，中间是库的名字和后缀 ``.so``，最后面跟着的三个数字组成版本号。

- ``x`` 代表主版本号（Major Version Number）：表示库的重大升级，不同主版本号的库是互相不兼容的。

- ``y`` 代表次版本号（Minor Version Number）：表示库的增量升级，即增加一些接口，原有接口保持不变，具有向前兼容的特征。

- ``z`` 代表发布版本号（Release Version Number）：表示一些错误的修正，性能的提升等，不增加新的接口，具有前后兼容性。

### 8.1.3 SO-NAME

根据共享库版本号的特征，动态链接器要加载一个共享库时，只需要知道主版本号，然后在次版本号和发布版本号中选择最高的版本即可。

SO-NAME 所指的就是仅包含主版本号的库名，比如 libfoo.so.2.6.1，它的 SO-NAME 为 libfoo.so.2。

在 Linux 系统中，系统会为每个共享库在它所在的目录创建一个名为 SO-NAME 的软链接（Symbol Link）以供动态链接器使用。
所有以 SO-NAME 为名的软链接都会指向该目录中共享库最新的版本。

这个 SO-NAME 在编译阶段会被保存到 ``.dynamic`` 字段中，这样动态链接器将来在查找依赖库的时候，可以解析 SO-NAME 来获取主版本号。

## 8.2 符号版本

单靠 SO-NAME 还存在这样一个问题：如果 ELF 文件在编译时的共享库次版本要高于运行时共享库的次版本，则可能会出现缺少符号的错误。
为了让这种错误可以在链接之前暴露，而不是在链接的时候才被发现，Linux 提供了基于符号的版本机制。

### 8.2.1 基于符号的版本机制

此方案的基本思路是让每个导出和导入的符号都有一个相关联的版本号。比如将 libfoo.so.1.2 升级到 libfoo.so.1.3 时增加了一个名为 foo 的符号，则该符号要加上后缀 ``VERS_1.3``，表示这个符号是在版本 1.3 中被加入的。

动态链接器在解析依赖时，除了通过 SO-NAME 查看主版本，还可以通过符号后缀来查看最高的次版本，因此可以在真正链接之前就判断出当前系统能否满足 ELF 文件的链接需求。

### 8.2.2 Solaris 中的符号版本机制

Solaris 的动态链接器为共享库增加了版本机制和范围机制。版本机制也就是上节所讲的基于符号的版本机制，范围机制则值得是符号的可见范围，举例如下：

```bash
SUNW_1.1 { 
global:
    pop;
    push;
}

SUMWprivate{
global:
    __pop;
    __push;
local:
    *;
}
```

在上面这个脚本文件中有两个符号集合，分别是 ``SUNW_1.1`` 和 ``SUNW_PRIVATE``。
第一个包含了两个全局符号 ``pop`` 和 ``push``，
第二个包含了两个全局符号 ``__pop`` 和 ``__push``，而其他的符号都被声明为局部符号，不能在库外访问。

当共享库升级时，假设其更新为增加了一个 ``swap`` 函数，则全新的符号版本脚本可以这样来编写：

```bash
SUNW_1.2 {
global:
    swap;
} SUNW_1.1;
```

### 8.2.3 Linux 中的符号版本机制

Linux 中的符号版本机制主要使用在 Glibc 软件包中所提供的二十几个库，并没有被广泛应用。
但是相比于 Solaris，Linux 提供了汇编指令 ``.symver`` 来实现更灵活的版本控制。

1. 除了通过版本脚本指定版本，还可以在代码中使用汇编指令来完成

>>```cpp
>>asm(".symver add, add@VERS_1.1");
>>int add(int, int);
>>```

2. 支持不同版本的符号重载

>>```cpp
>>asm(".symver old_printf, printf@VERS_1.1");
>>asm(".symver new_printf, printf@VERS_1.2");
>>int old_printf();
>>int new_printf();
>>```

## 8.3 共享库系统路径

也就是熟悉的 ``/lib``、``/usr/lib`` 和 ``/usr/local/lib``。

## 8.4 共享库查找过程

使用动态链接的 ELF 文件会把其所以来的库路径保存在 ``.dynamic`` 段中。
如果路径是绝对地址，则直接查找绝对地址。
如果路径是相对地址，则会在共享库系统路径中查找库文件。

## 8.5 环境变量

可以通过配置环境变量的方式来更改动态链接器的查找行为。

**LD_LIBRARY_PATH**

额外的共享库查找路径。

**LD_PRELOAD**

指定动态链接器要装载的共享库，且最先被装载，不论其是否被用到。
由于全局符号介入机制的存在，使用 LD_PRELOAD 可以跟方便地改写某个 C 标准库中的函数。

**LD_DEBUG**

显示动态链接时的详细信息。

可选值参考《程序员的自我修养》对应章节。

## 8.6 共享库的创建和安装

### 8.6.1 共享库的创建

用 GCC 编译时加上 ``-shared`` 和 ``-fPIC`` 参数即可。

此外，还可以通过 ``-Wl`` 传递一些额外的参数给链接器，
比如 ``-Wl,-soname,libfoo.so.1,-rpath,/home/user/.local/lib/`` 指定 SO-NAME 和优先查找共享库的路径。

### 8.6.2 清除符号信息

正常编译出来的共享库包含符号信息和调试信息，可以通过 ``strip`` 命令或者编译时的 ``-Wl,-s`` 或者 ``-Wl,-S`` 选项来去除。
``-S`` 去除调试信息，``-s`` 消除所有信息。

```bash
strip libfoo.so
```

### 8.6.3 共享库的安装

直接拷贝到某个共享库系统路径下，如 ``/lib``，然后执行 ``ldconfig`` 即可。

没有管理权限的情况下可以直接执行 ``ldconfig``：

```bash
ldconfig -n <your_shared_library_path>
```

### 8.6.4 共享库构造和析构函数

GCC 提供了一种共享库的构造函数，只要在函数声明时加上 ``__attribute__((constructor))`` 的属性，即指定该函数为共享库的构造函数，这些构造函数会在共享库被装载时执行（main/dlopen 函数之前）。
析构函数同理（在 dlclose 函数之前被执行）。

```cpp
void __attribute__((constructor)) init_fun(void);
void __attribute__((destructor)) fini_fun(void);
```

可以声明多个构造和析构函数，其执行顺序并没有严格规则。

### 8.6.5 共享库脚本

可以使用动态链接器将不同的共享库文件拼接在一起，《程序员的自我修养》中没有介绍具体方法。
