# 第十二章 系统调用与 API

## 12.1 系统调用介绍

### 12.1.1 什么是系统调用

系统调用（System Call）是计算机程序向其执行的操作系统内核请求服务的一种程序化方式。
系统调用涵盖的功能很广，有程序运行所必需的支持，例如创建和退出进程、进程内存管理，对操作系统资源的访问等。

系统调用可以保护计算机资源，为程序提供睡眠唤醒等自身无法有效完成的功能。

### 12.1.2 Linux 系统调用

在 x86 下，系统调用由 0x80 中断完成，各个通用寄存器用于传递参数。EAX 寄存器用于表示系统调用的接口号，比如 
EAX = 1 表示退出进程；EAX = 2 表示创建进程；EAX = 3 表示 IO(READ)；EAX = 4 表示 IO(WRITE) 等。
当系统调用完成后，EAX 寄存器又将作为调用结果的返回值。

Linux 内核版本 2.6.19 提供了 319 个系统调用，他们都对应内核源码中以 ``sys_`` 开头的一个函数。

### 12.1.3 系统调用的弊端

系统调用完成了应用程序和内核交流的工作，理论上只需要系统调用就可以满足程序的要求。但是大多数系统调用都有这两个缺点：

- 接口过于原始，直接使用不太方便。

- 不同操作系统之间的系统调用不兼容。

为了解决这两个问题，可以使用“万能法则”：解决计算机的问题可以通过增加层来实现，于是运行库挺身而出了。
运行库作为系统调用与程序之间的一个抽象层，始终保持着这样的特点：

- 使用简便，因为运行库本身就是语言级别的，它一般都设计相对比较友好。

- 形式统一，不存在各个操作系统的兼容性问题。

运行库的缺点是只能够取各平台系统调用功能的交集。

## 12.2 系统调用原理

### 12.2.1 特权级与终端

现代 CPU 可以在多种截然不同的特权级别下执行指令，最常见的是用户模式（User Mode）和内核模式（Kernel Mode），也被称为用户态和内核态。
由于有多个特权模式的存在，操作系统可以让不同的代码运行在不同的模式上，以限制他们的权力，提供系统稳定性和安全性。普通应用程序运行在用户态的模式下，诸多操作收到限制，包括访问硬件设备，开关终端，改变特权模式等。

操作系统一般通过中断（Interrupt）来从用户态切换到内核态。
中断具有两个属性，一个是中断号（从 0 开始），另一个是中断处理程序。不同的中断具有不同的中断号和中断处理程序。
在内核中，有一个数组称为中断向量表（Interrupt Vector Table），这个数组的第 n 项包含了指向第 n 号中断的中断处理程序的指针。

中断有两种类型：硬件中断和软件中断。前者来自于硬件的异常或者其他事件的发生，如电源掉电，键盘被按下等。后者是一条指令，可以在程序中使用指令引发中断，如程序抛出异常。

操作系统会用一个或几个中断来对应操作系统的系统调用，配合 EAX 寄存器的值来决定是哪条系统调用。

### 12.2.2 基于 int 的 Linux 的经典系统调用实现

以 ``fork`` 为例：

<div align="center">
<img src="https://github.com/xpmemeda/task/raw/master/chrome-review-list/Link-Load-and-Library/resource/12-3.jpg" width = "500" height = "250" alt="图 12-3 Linux 系统中断流程"/>
</div>

1. 触发中断：``fork`` 源码中调用中断指令 ``int $x80``
2. 切换堆栈：保存当前程序执行的上下文
3. 运行中断处理程序

Q：内核中以 sys 开头的系统调用函数如何从用户那里获得参数？

A：根据系统调用参数数量的不同，依次将参数放入 EBX、ECX、EDX、ESI、ESI 和 EBP 这六个寄存器中。

### 12.2.3 Linux 的新型系统调用机制

Linux2.5 之后支持另一组系统调用指令：``sysenter`` 和 ``sysexit``。``sysenter`` 会直接调转到由某个寄存器指定的函数执行，并自动完成特权级别转换，堆栈切换等功能。

## 12.3 Windows API
