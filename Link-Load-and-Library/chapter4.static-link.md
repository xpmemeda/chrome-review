# 第四章 静态链接

## 4.1 空间与地址分配

### 4.1.1 按序叠加

直接将目标文件依次合并，这个方案不行。

### 4.1.2 相似段合并

将不同目标文件中同类型的段合并到一起。使用这种方法的链接器一般都采用两部链接（Two-pass Linking）：

**第一步 空间和地址分配** 扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局符号表。此时每个符号值都已经确定了。
这一步中，链接器能够获得所有目标文件的段长度，并且将他们合并起来，计算出输出文件中各个段合并之后的长度与位置，并建立映射关系。

**第二步 符号解析与重定位** 使用第一步收集到的信息，读取输入文件中段的数据、重定位信息，并且进行符号解析与重定位、调整代码中的地址等。

所谓地址和空间其实包含两个含义：一是在输出的可执行文件中的空间；另一个是在装载后的虚拟地址中的虚拟地址空间。
对于有实际数据的段，比如 ``.text`` 和 ``.data`` 来说，它们在文件和虚拟地址中都要分配空间；
而对于 ``.bss`` 这样的段来说，分配空间的意义只局限于虚拟地址空间。
事实上，在链接过程中谈到的空间分配只关注于虚拟地址的分配。

``.bss`` 段在目标文件和可执行文件中并不占用文件的空间，但是它在装载时占用地址空间。
所以链接器在合并各个段的同时，也将 ``.bss`` 段合并，并且分配虚拟空间。

在 Linux 系统下，ELF 可执行文件默认地址从 0x08048000 开始。

### 4.1.3 符号地址的确定

## 4.2 符号解析与重定位

### 4.2.1 重定位

在当前目标文件中引用的外部符号，其值会被编译器标记为 0x00000000（绝对地址引用）或者 0xFFFFFFFC（相对地址引用），真正的计算工作则留给链接器来完成。

### 4.2.2 重定位表

链接器依赖重定位表（Relocation Table）来获知哪些指令和数据需要被调整，以及如何调整等信息。重定位表中会记录需要调整的指令或数据相对于段开头的地址。
重定位表在 ELF 文件中以段的形式存在，段名通常为 ``.rel.text`` 和 ``.rel.data``。

使用 ``objdump -r`` 可以查看目标文件中所有需要被重定位的地方，也叫做重定位入口（Relocation Entry）。

### 4.2.3 符号解析

重定位过程中，每个重定位的入口都是对一个符号的引用，那么当链接器对某个符号的引用进行重定位时，他就要确定这个符号的目标地址。
这时候链接器就回去查找由所有输入目标文件的符号表组成的全局符号表，找到对应的符号后进行重定位。

### 4.2.4 指令修正方式

寻址方式可以被分为近址寻址和远址寻址，绝对寻址和相对寻址，不同寻址长度如 8 位、16 位等等。
但是 x86 平台下 ELF 文件的重定位入口所修正的指令寻址方式只有两种，其修正方式大致如下：

- 绝对近址 32 为寻址，修正方法为 S + A
- 相对近址 32 为寻址，修正方法为 S + A - P

A：保存在被修正位置的值，前文提到绝对寻址是 0x00000000，相对寻址是 0xFFFFFFFC

P：所在段开始的位置

S：符号的实际地址

## 4.3 COMMON 块

COMMON 块（Common Block）是为了解决多个弱符号名字冲突而诞生的机制，也就是将弱符号标记为 COMMON 类型，然后存放在 COMMON 块中，直到弱符号解析完成之后在放到对应的段中。

Q：在目标文件中，为什么未初始化的全局变量没有在 ``.bss`` 段中，而是被标记为一个 COMMON 类型的符号？

A：未初始化的全局变量是弱符号，因此只有在链接全部完成之后才知道它真实的占用空间大小，放在 ``.bss`` 段会导致该段的虚拟地址无法计算。
然而在可执行文件中，也就是链接完成之后，未初始化的全局变量的占用空间大小被确定下来，还是会被放到 ``.bss`` 段。

## 4.4 C++ 相关问题

### 4.4.1 重复代码消除

C++ 编译其在很多时候都会在不同的编译单元产生相同的代码，比如模板在不同的模块中被具体化，虚函数表在不同的模块中被生成等等。
重复代码存在许多问题比如空间浪费，地址解析出错，运行效率底。

一个比较有效的解决办法是将每个模板的实例代码都单独存放在一个段中，每个段仅包含一个实例模板。
比如有个模板函数为 ``add<T>()``，某个编译单元以 int 类型和 float 类型实例化了该模板函数，那么该编译单元内就有两个名为例如 ``.temp.add<int>`` 和 ``.temp.add<float>`` 的段。
当别的编译单元也以 int 和 float 类型实例化改模板函数后，会生成同样名字的段，这样链接器在链接的时候就可以区分这些相同的模板实例段。

GCC 中把这种类似的需要在最终链接时合并的段叫做 Link Once。

**函数级别链接**

由于现在程序和库都非常庞大，因此有一种名为函数级别链接（Functional-Level Linking）的技术。
它把每个函数都放在一个单独的段中，在链接时只把用到的那些段放进可执行文件中。

函数级别链接可以有效减小输出文件的长度，但是会导致编译链接过程非常缓慢，重定位更加困难，中间目标文件也变得更大。

### 4.4.2 全局构造与析构

构造函数存放在 ``.init`` 段中，该段指令会在 ``main`` 函数之前由入口函数调用执行。
析构函数存放在 ``.fini`` 段中，该段指令会在 ``main`` 函数之后由入口函数调用执行。

### 4.4.3 C++ 与 ABI

不同编译器生成的目标文件在多数场合不能相互链接，原因是它们的符号修饰标准、变量的内存分布方式、函数的调用方式等都不相同。
这些跟可执行二进制兼容性相关的内容被称为 ABI（Application Binary Interface）。ABI 更像是一种标准或协议。

## 4.5 静态库链接

Q：为什么静态运行库里面一个目标文件只包含一个函数？

A：链接器在链接静态库的时候是以目标文件为单位的，如果目标文件中包含多个函数，则会引入一些不需要的函数到输出文件中。

## 4.6 连接过程控制

## 4.6.1 链接控制脚本

链接器一般都提供多种控制整个链接过程的方法，常见的以下三种：

1. 使用命令行来给链接器指定参数，比如 ld 的 -e（程序主函数名，默认为 main） -o（输出文件名） 参数。
2. 将链接指令存放在目标文件中，编译器经常会通过这种方法来向链接器传递指令。
3. 使用链接控制脚本。

ld 在用户没有指定链接脚本的时候会使用 ``/usr/lib/ldscripts`` 目录下的默认链接脚本。

### 4.6.2 最小的程序

GCC 支持内嵌汇编，比如：

```cpp
char* str = "Hello world\n";
void print() {
    asm("mov $13, %%edx \n\t"  // 参数寄存器 edx，表示字符串长度为 13
        "mov %0, %%ecx  \n\t"  // 参数寄存器 ecx，表示字符串 str
        "mov $0, %%ebx  \n\t"  // 参数寄存器 ebx，表示默认终端 stdout
        "mov $4, %%eax  \n\t"  // eax，表示系统调用号，write：4
        "int $0x80      \n\t"  // 触发中断
        ::"r"(str):"edx","ecx","ebx"
    );
}
void exit() {
    asm("mov $42, %ebx \n\t"  // 参数寄存器 ebx，表示程序返回值为 42
        "mov $1, %eax  \n\t"  // eax，系统调用号，exit：1
        "int $0x80     \n\t"
    );
}
void nomain() {
    print();
    exit();
}
```

### 4.6.3 使用 ld 链接脚本

使用 ``;`` 作为分隔符，``/* */`` 作为注释符。示例：

```c
ENTRY(nomain)

SECTIONS
{
    . = 0X08048000 + SIZEOF_HEADERS;  /* 设置当前虚拟地址 */
    tinytext : {*(.text) *(.data) *(.rodata)}  /* 合并指定段 */
    /DISCARD/ : {*(comment)}  /*忽略指定段 */
}
```

## 4.7 BFD 库

BFD（Binary File Descriptor library）是一个 GNU 项目，用来处理编译器和链接器处理不同平台之间的目标文件。

BFD 为目标文件提供一个统一的模型，一旦我们需要支持一种新的目标文件格式，只要在 BFD 库中添加一种格式就可以了。
