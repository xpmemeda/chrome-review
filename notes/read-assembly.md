### 通过看汇编代码（Assembly）查问题

**汇编指令文档**

[x86 and amd64 instruction reference](https://www.felixcloutier.com/x86/index.html)

**常见寄存器**
- rbp 栈帧的顶部（基址：Linux系统下栈由高地址向低地址生长）
- rsp 栈帧的底部
- pc  程序计数器，指向当前指令（导致core的指令）
- ymm AVX256bit向量寄存器
- xmm SSE128bit向量寄存器

**标志位**

零标志（ZF）：如果结果为0，那么零标志被设置为1，否则被设置为0。

符号标志（SF）：如果结果为负（在二进制补码表示中，最高位为1表示负数），那么符号标志被设置为1，否则被设置为0。

进位标志（CF）：如果发生无符号溢出，那么进位标志被设置为1，否则被设置为0。

溢出标志（OF）：如果发生有符号溢出，那么溢出标志被设置为1，否则被设置为0。

奇偶标志（PF）：如果结果中1的数量为偶数，那么奇偶标志被设置为1，否则被设置为0。

**寻址方式**

以``0x4(%rbp, %r8, 2)``为例，目标地址为``%rbp + 2 * %r8 + 0x4``。可以看看CSAPP。

**GDB.获取堆栈地址空间**

(gdb) info proc mappings

一些要点：
- 打印出来的地址通常是长度为12的16进制数，Linux x64使用48bit来表示虚拟地址空间。
- Linux一个进程的默认栈大小通常是8MB，可以使用``ulimis -s``指令来展示和修改栈的大小。
- 多线程程序，非主线程的栈是系统调用mmap返回的一个堆区地址（一个单独的段），其大小就是系统配置的栈大小。

**GDB.打印栈帧**

通常用``bt``命令来打印调用栈，但在JIT代码里面会不准。此时用``x/5i *(int64_t*)($rbp + 8) - 10``可以查询到调用处的指令。
地址``$rbp+8``存储当前函数的返回地址（由callq指令填充，指向调用方的下一条指令）。

**GDB.设置断点**

(gdb) break *address

**GDB.调试指令**
- n
执行本行源码

- ni
执行本条指令

- s
执行本行源码，函数则跳转

- si
执行本条指令，函数则跳转

- disassemble
打印当前函数的汇编代码，即使是release编译也有函数签名信息，但是jit的没有。

- x
查看地址内容：[文档](https://visualgdb.com/gdbreference/commands/x)

- p
打印信息

**GDB.打印信息**

- p

查看常见寄存器的值：加上``/x``打印16进制

```
p $rsp      栈顶
p $eflags   控制位（ZL,CL...）
p $rax      查看通用寄存器rax的值
```

- x

打印指令

```
x/10i $pc
```

**常见问题**

- 爆栈

程序运行时Segfault，gdb调试时弹出Cannot access memory at address（访问不可读内存地址）

发生过程：
1. 修改rsp的值，栈溢出发生时，rsp可以正常被修改，但是其值已经超出了栈的范围。
2. 通过rsp来访问栈内的变量，此时可能出现内存越界，程序退出。

解决办法：在挂的地方打印rsp，和调用前的rsp对比，看看是不是差值过大。确定是栈溢出后可以把栈调大。

- 读写越界

越界不一定会产生segfault，只有读写地址超过了系统分配的段空间地址才会segfault。

解决办法：直接读汇编代码，理解出错的源代码逻辑，找到一些关键信息，比如算子的输入个数，通过打印寄存器的值获取维度信息。

**一些有用的常识**

- 函数的前两条指令通常是``push $rbp``和``mov %rsp,%rbp``，用于栈帧信息。
- ``$rbp + 8``是由``callq``指令填充的返回地址。
- 算数指令会修改标志位寄存器，具体修改哪些位不确定。